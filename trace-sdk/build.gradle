apply plugin: 'jacoco'
apply plugin: 'com.android.library'

android {
    compileSdkVersion 30
    buildToolsVersion "29.0.2"
    defaultConfig {
        minSdkVersion 22
        targetSdkVersion 30
        versionCode = "$project.versionCode" as int
        versionName "$project.version"
        buildConfigField('String', 'VERSION_NAME', "\"${project.version}\"")
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = ["room.schemaLocation": "$projectDir/schemas".toString()]
            }
        }
    }
    buildTypes {
        debug {
            minifyEnabled false
            testCoverageEnabled true
        }
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

jacoco {
    toolVersion = "0.8.5"
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
    // see related issue https://github.com/gradle/gradle/issues/5184#issuecomment-457865951
}

project.afterEvaluate {
    // A Set that will contain all the report task names for each variant
    Set<String> reportTaskNames = new HashSet<>()
    android.'libraryVariants'
            .all { variant ->
                def variantName = variant.name
                def unitTestTask = "test${variantName.capitalize()}UnitTest"
                def androidTestCoverageTask = "create${variantName.capitalize()}CoverageReport"

                // Add the report task name for the given variant to the Set above
                reportTaskNames.add("create${variantName.capitalize()}AndroidTestCoverageReport")

                tasks.create(name: "${unitTestTask}Coverage", type: JacocoReport, dependsOn: [
                        "$unitTestTask",
                        "$androidTestCoverageTask"
                ]) {
                    group = "Reporting"
                    description = "Generate Jacoco coverage reports for the ${variantName.capitalize()} build"

                    reports {
                        html.enabled = true
                        xml.enabled = true
                        csv.enabled = true
                    }

                    def excludes = [
                            '**/R.class',
                            '**/R$*.class',
                            '**/BuildConfig.*',
                            '**/Manifest*.*',
                            '**/*Test*.*',
                            'android/**/*.*',
                    ]

                    def javaClasses = fileTree(dir: variant.javaCompileProvider.get().destinationDir,
                            excludes: excludes)

                    classDirectories.setFrom(files([
                            javaClasses
                    ]))

                    def variantSourceSets = variant.sourceSets.java.srcDirs.collect { it.path }.flatten()
                    sourceDirectories.setFrom(project.files(variantSourceSets))

                    def androidTestsData = fileTree(dir: "${buildDir}/outputs/code_coverage/${variantName}AndroidTest/connected/", includes: ["**/*.ec"])

                    executionData(files([
                            "$project.buildDir/jacoco/${unitTestTask}.exec",
                            androidTestsData
                    ]))
                }
            }
    // Get the task of running the connected tests
    Task connectedAndroidTestTask = tasks.findByName("connectedAndroidTest")
    // Create a set that will contain the required dependsOn elements
    Set<?> deps = new HashSet<>();
    connectedAndroidTestTask.dependsOn.each {
        // Filter out Jacoco report tasks. this is an issue, connected tests should not depend on them
        String providerName = ((TaskProvider) it).getName()
        if (!reportTaskNames.grep{it == providerName}) {
            deps.add(it)
        }
    }
    // Replace the original dependsOn with the filtered
    connectedAndroidTestTask.setDependsOn(deps)

    // Finally make sure that each report task depends on the connected tests.
    reportTaskNames.forEach({
        // Will be null, if testCoverageEnabled is false for the given variant
        def reportTask = tasks.findByName(it)
        if (reportTask != null) {
            reportTask.dependsOn(connectedAndroidTestTask)
        }
    })
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "androidx.concurrent:concurrent-futures:${versions.concurrentFutures}"
    implementation "androidx.room:room-runtime:${versions.room}"
    implementation "androidx.lifecycle:lifecycle-livedata:${versions.liveData}"
    implementation "androidx.fragment:fragment:${versions.fragment}"
    implementation "androidx.appcompat:appcompat:${versions.appcompat}"
    annotationProcessor "androidx.room:room-compiler:${versions.room}"

    implementation "javax.inject:javax.inject:${versions.javaxInject}"
    implementation "com.squareup.retrofit2:retrofit:${versions.retrofit}"
    implementation "com.squareup.okhttp3:logging-interceptor:${versions.okhttp}"
    implementation "com.squareup.retrofit2:converter-gson:${versions.converterGson}"
    implementation("com.squareup.okhttp3:okhttp") {
        version { require versions.okhttp }
        because constraintReasons.okhttp
    }
    implementation "io.bitrise.trace.internal:opencensus:${versions.opencensus}"
    implementation("com.google.guava:listenablefuture:${versions.listenableFuture}") {
        because constraintReasons.guava
    }
    implementation "io.azam.ulidj:ulidj:${versions.ulidj}"
    implementation("com.scottyab:rootbeer-lib:${versions.rootbeer}") {
        because constraintReasons.rootBeer
    }

    testImplementation "junit:junit:${versions.junit}"
    testImplementation "org.mockito:mockito-core:${versions.mockitoCore}"
    testImplementation "org.hamcrest:hamcrest:${versions.hamcrest}"
    testImplementation "androidx.room:room-testing:${versions.room}"

    androidTestImplementation "androidx.test:core:${versions.androidxTest}"
    androidTestImplementation("androidx.test:runner:${versions.androidxTest}") {
        exclude group: "org.hamcrest", module: "hamcrest-core"
    }
    androidTestImplementation("androidx.test:rules:${versions.androidxTest}") {
        exclude group: "org.hamcrest", module: "hamcrest-core"
    }
    androidTestImplementation("androidx.test.ext:junit:${versions.extJunit}") {
        exclude group: "org.hamcrest", module: "hamcrest-core"
    }
    androidTestImplementation "org.hamcrest:hamcrest:${versions.hamcrest}"
    androidTestImplementation "org.mockito:mockito-android:${versions.mockitoAndroid}"
}
apply from: "release-trace-sdk.gradle"