// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opencensus/proto/metrics/v1/metrics.proto

package io.opencensus.proto.metrics.v1;

/**
 * <pre>
 * Distribution contains summary statistics for a population of values. It
 * optionally contains a histogram representing the distribution of those
 * values across a set of buckets.
 * </pre>
 *
 * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue}
 */
public  final class DistributionValue extends
    com.google.protobuf.GeneratedMessageLite<
        DistributionValue, DistributionValue.Builder> implements
    // @@protoc_insertion_point(message_implements:opencensus.proto.metrics.v1.DistributionValue)
    DistributionValueOrBuilder {
  private DistributionValue() {
    buckets_ = emptyProtobufList();
  }
  public interface BucketOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opencensus.proto.metrics.v1.DistributionValue.BucketOptions)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     * @return Whether the explicit field is set.
     */
    boolean hasExplicit();
    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     * @return The explicit.
     */
    io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit getExplicit();

    public io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * A Distribution may optionally contain a histogram of the values in the
   * population. The bucket boundaries for that histogram are described by
   * BucketOptions.
   * If bucket_options has no type, then there is no histogram associated with
   * the Distribution.
   * </pre>
   *
   * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.BucketOptions}
   */
  public  static final class BucketOptions extends
      com.google.protobuf.GeneratedMessageLite<
          BucketOptions, BucketOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:opencensus.proto.metrics.v1.DistributionValue.BucketOptions)
      BucketOptionsOrBuilder {
    private BucketOptions() {
    }
    public interface ExplicitOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @return A list containing the bounds.
       */
      java.util.List<java.lang.Double> getBoundsList();
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @return The count of bounds.
       */
      int getBoundsCount();
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @param index The index of the element to return.
       * @return The bounds at the given index.
       */
      double getBounds(int index);
    }
    /**
     * <pre>
     * Specifies a set of buckets with arbitrary upper-bounds.
     * This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
     * index i are:
     * [0, bucket_bounds[i]) for i == 0
     * [bucket_bounds[i-1], bucket_bounds[i]) for 0 &lt; i &lt; N-1
     * [bucket_bounds[i], +infinity) for i == N-1
     * </pre>
     *
     * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit}
     */
    public  static final class Explicit extends
        com.google.protobuf.GeneratedMessageLite<
            Explicit, Explicit.Builder> implements
        // @@protoc_insertion_point(message_implements:opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit)
        ExplicitOrBuilder {
      private Explicit() {
        bounds_ = emptyDoubleList();
      }
      public static final int BOUNDS_FIELD_NUMBER = 1;
      private com.google.protobuf.Internal.DoubleList bounds_;
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @return A list containing the bounds.
       */
      @java.lang.Override
      public java.util.List<java.lang.Double>
          getBoundsList() {
        return bounds_;
      }
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @return The count of bounds.
       */
      @java.lang.Override
      public int getBoundsCount() {
        return bounds_.size();
      }
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @param index The index of the element to return.
       * @return The bounds at the given index.
       */
      @java.lang.Override
      public double getBounds(int index) {
        return bounds_.getDouble(index);
      }
      private int boundsMemoizedSerializedSize = -1;
      private void ensureBoundsIsMutable() {
        com.google.protobuf.Internal.DoubleList tmp = bounds_;
        if (!tmp.isModifiable()) {
          bounds_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @param index The index to set the value at.
       * @param value The bounds to set.
       */
      private void setBounds(
          int index, double value) {
        ensureBoundsIsMutable();
        bounds_.setDouble(index, value);
      }
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @param value The bounds to add.
       */
      private void addBounds(double value) {
        ensureBoundsIsMutable();
        bounds_.addDouble(value);
      }
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       * @param values The bounds to add.
       */
      private void addAllBounds(
          java.lang.Iterable<? extends java.lang.Double> values) {
        ensureBoundsIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, bounds_);
      }
      /**
       * <pre>
       * The values must be strictly increasing and &gt; 0.
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      private void clearBounds() {
        bounds_ = emptyDoubleList();
      }

      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Specifies a set of buckets with arbitrary upper-bounds.
       * This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
       * index i are:
       * [0, bucket_bounds[i]) for i == 0
       * [bucket_bounds[i-1], bucket_bounds[i]) for 0 &lt; i &lt; N-1
       * [bucket_bounds[i], +infinity) for i == N-1
       * </pre>
       *
       * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit, Builder> implements
          // @@protoc_insertion_point(builder_implements:opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit)
          io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.ExplicitOrBuilder {
        // Construct using io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @return A list containing the bounds.
         */
        @java.lang.Override
        public java.util.List<java.lang.Double>
            getBoundsList() {
          return java.util.Collections.unmodifiableList(
              instance.getBoundsList());
        }
        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @return The count of bounds.
         */
        @java.lang.Override
        public int getBoundsCount() {
          return instance.getBoundsCount();
        }
        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @param index The index of the element to return.
         * @return The bounds at the given index.
         */
        @java.lang.Override
        public double getBounds(int index) {
          return instance.getBounds(index);
        }
        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @param value The bounds to set.
         * @return This builder for chaining.
         */
        public Builder setBounds(
            int index, double value) {
          copyOnWrite();
          instance.setBounds(index, value);
          return this;
        }
        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @param value The bounds to add.
         * @return This builder for chaining.
         */
        public Builder addBounds(double value) {
          copyOnWrite();
          instance.addBounds(value);
          return this;
        }
        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @param values The bounds to add.
         * @return This builder for chaining.
         */
        public Builder addAllBounds(
            java.lang.Iterable<? extends java.lang.Double> values) {
          copyOnWrite();
          instance.addAllBounds(values);
          return this;
        }
        /**
         * <pre>
         * The values must be strictly increasing and &gt; 0.
         * </pre>
         *
         * <code>repeated double bounds = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearBounds() {
          copyOnWrite();
          instance.clearBounds();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bounds_",
              };
              java.lang.String info =
                  "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001#";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit> parser = PARSER;
            if (parser == null) {
              synchronized (io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit)
      private static final io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit DEFAULT_INSTANCE;
      static {
        Explicit defaultInstance = new Explicit();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Explicit.class, defaultInstance);
      }

      public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Explicit> PARSER;

      public static com.google.protobuf.Parser<Explicit> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase {
      EXPLICIT(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return EXPLICIT;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    private void clearType() {
      typeCase_ = 0;
      type_ = null;
    }

    public static final int EXPLICIT_FIELD_NUMBER = 1;
    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     */
    @java.lang.Override
    public boolean hasExplicit() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     */
    @java.lang.Override
    public io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit getExplicit() {
      if (typeCase_ == 1) {
         return (io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit) type_;
      }
      return io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.getDefaultInstance();
    }
    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     */
    private void setExplicit(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit value) {
      value.getClass();
  type_ = value;
      typeCase_ = 1;
    }
    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     */
    private void mergeExplicit(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit value) {
      value.getClass();
  if (typeCase_ == 1 &&
          type_ != io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.getDefaultInstance()) {
        type_ = io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.newBuilder((io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit) type_)
            .mergeFrom(value).buildPartial();
      } else {
        type_ = value;
      }
      typeCase_ = 1;
    }
    /**
     * <pre>
     * Bucket with explicit bounds.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
     */
    private void clearExplicit() {
      if (typeCase_ == 1) {
        typeCase_ = 0;
        type_ = null;
      }
    }

    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A Distribution may optionally contain a histogram of the values in the
     * population. The bucket boundaries for that histogram are described by
     * BucketOptions.
     * If bucket_options has no type, then there is no histogram associated with
     * the Distribution.
     * </pre>
     *
     * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.BucketOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:opencensus.proto.metrics.v1.DistributionValue.BucketOptions)
        io.opencensus.proto.metrics.v1.DistributionValue.BucketOptionsOrBuilder {
      // Construct using io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public TypeCase
          getTypeCase() {
        return instance.getTypeCase();
      }

      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }


      /**
       * <pre>
       * Bucket with explicit bounds.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
       */
      @java.lang.Override
      public boolean hasExplicit() {
        return instance.hasExplicit();
      }
      /**
       * <pre>
       * Bucket with explicit bounds.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
       */
      @java.lang.Override
      public io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit getExplicit() {
        return instance.getExplicit();
      }
      /**
       * <pre>
       * Bucket with explicit bounds.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
       */
      public Builder setExplicit(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit value) {
        copyOnWrite();
        instance.setExplicit(value);
        return this;
      }
      /**
       * <pre>
       * Bucket with explicit bounds.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
       */
      public Builder setExplicit(
          io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.Builder builderForValue) {
        copyOnWrite();
        instance.setExplicit(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Bucket with explicit bounds.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
       */
      public Builder mergeExplicit(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit value) {
        copyOnWrite();
        instance.mergeExplicit(value);
        return this;
      }
      /**
       * <pre>
       * Bucket with explicit bounds.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1;</code>
       */
      public Builder clearExplicit() {
        copyOnWrite();
        instance.clearExplicit();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opencensus.proto.metrics.v1.DistributionValue.BucketOptions)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "type_",
              "typeCase_",
              io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0001\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001<\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions> parser = PARSER;
          if (parser == null) {
            synchronized (io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:opencensus.proto.metrics.v1.DistributionValue.BucketOptions)
    private static final io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions DEFAULT_INSTANCE;
    static {
      BucketOptions defaultInstance = new BucketOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BucketOptions.class, defaultInstance);
    }

    public static io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BucketOptions> PARSER;

    public static com.google.protobuf.Parser<BucketOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BucketOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opencensus.proto.metrics.v1.DistributionValue.Bucket)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The number of values in each bucket of the histogram, as described in
     * bucket_bounds.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     * @return The count.
     */
    long getCount();

    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     * @return Whether the exemplar field is set.
     */
    boolean hasExemplar();
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     * @return The exemplar.
     */
    io.opencensus.proto.metrics.v1.DistributionValue.Exemplar getExemplar();
  }
  /**
   * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.Bucket}
   */
  public  static final class Bucket extends
      com.google.protobuf.GeneratedMessageLite<
          Bucket, Bucket.Builder> implements
      // @@protoc_insertion_point(message_implements:opencensus.proto.metrics.v1.DistributionValue.Bucket)
      BucketOrBuilder {
    private Bucket() {
    }
    public static final int COUNT_FIELD_NUMBER = 1;
    private long count_;
    /**
     * <pre>
     * The number of values in each bucket of the histogram, as described in
     * bucket_bounds.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     * @return The count.
     */
    @java.lang.Override
    public long getCount() {
      return count_;
    }
    /**
     * <pre>
     * The number of values in each bucket of the histogram, as described in
     * bucket_bounds.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     * @param value The count to set.
     */
    private void setCount(long value) {
      
      count_ = value;
    }
    /**
     * <pre>
     * The number of values in each bucket of the histogram, as described in
     * bucket_bounds.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     */
    private void clearCount() {
      
      count_ = 0L;
    }

    public static final int EXEMPLAR_FIELD_NUMBER = 2;
    private io.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar_;
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     */
    @java.lang.Override
    public boolean hasExemplar() {
      return exemplar_ != null;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     */
    @java.lang.Override
    public io.opencensus.proto.metrics.v1.DistributionValue.Exemplar getExemplar() {
      return exemplar_ == null ? io.opencensus.proto.metrics.v1.DistributionValue.Exemplar.getDefaultInstance() : exemplar_;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     */
    private void setExemplar(io.opencensus.proto.metrics.v1.DistributionValue.Exemplar value) {
      value.getClass();
  exemplar_ = value;
      
      }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeExemplar(io.opencensus.proto.metrics.v1.DistributionValue.Exemplar value) {
      value.getClass();
  if (exemplar_ != null &&
          exemplar_ != io.opencensus.proto.metrics.v1.DistributionValue.Exemplar.getDefaultInstance()) {
        exemplar_ =
          io.opencensus.proto.metrics.v1.DistributionValue.Exemplar.newBuilder(exemplar_).mergeFrom(value).buildPartial();
      } else {
        exemplar_ = value;
      }
      
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
     */
    private void clearExemplar() {  exemplar_ = null;
      
    }

    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(io.opencensus.proto.metrics.v1.DistributionValue.Bucket prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.Bucket}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          io.opencensus.proto.metrics.v1.DistributionValue.Bucket, Builder> implements
        // @@protoc_insertion_point(builder_implements:opencensus.proto.metrics.v1.DistributionValue.Bucket)
        io.opencensus.proto.metrics.v1.DistributionValue.BucketOrBuilder {
      // Construct using io.opencensus.proto.metrics.v1.DistributionValue.Bucket.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The number of values in each bucket of the histogram, as described in
       * bucket_bounds.
       * </pre>
       *
       * <code>int64 count = 1;</code>
       * @return The count.
       */
      @java.lang.Override
      public long getCount() {
        return instance.getCount();
      }
      /**
       * <pre>
       * The number of values in each bucket of the histogram, as described in
       * bucket_bounds.
       * </pre>
       *
       * <code>int64 count = 1;</code>
       * @param value The count to set.
       * @return This builder for chaining.
       */
      public Builder setCount(long value) {
        copyOnWrite();
        instance.setCount(value);
        return this;
      }
      /**
       * <pre>
       * The number of values in each bucket of the histogram, as described in
       * bucket_bounds.
       * </pre>
       *
       * <code>int64 count = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCount() {
        copyOnWrite();
        instance.clearCount();
        return this;
      }

      /**
       * <pre>
       * If the distribution does not have a histogram, then omit this field.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
       */
      @java.lang.Override
      public boolean hasExemplar() {
        return instance.hasExemplar();
      }
      /**
       * <pre>
       * If the distribution does not have a histogram, then omit this field.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
       */
      @java.lang.Override
      public io.opencensus.proto.metrics.v1.DistributionValue.Exemplar getExemplar() {
        return instance.getExemplar();
      }
      /**
       * <pre>
       * If the distribution does not have a histogram, then omit this field.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
       */
      public Builder setExemplar(io.opencensus.proto.metrics.v1.DistributionValue.Exemplar value) {
        copyOnWrite();
        instance.setExemplar(value);
        return this;
        }
      /**
       * <pre>
       * If the distribution does not have a histogram, then omit this field.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
       */
      public Builder setExemplar(
          io.opencensus.proto.metrics.v1.DistributionValue.Exemplar.Builder builderForValue) {
        copyOnWrite();
        instance.setExemplar(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * If the distribution does not have a histogram, then omit this field.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
       */
      public Builder mergeExemplar(io.opencensus.proto.metrics.v1.DistributionValue.Exemplar value) {
        copyOnWrite();
        instance.mergeExemplar(value);
        return this;
      }
      /**
       * <pre>
       * If the distribution does not have a histogram, then omit this field.
       * </pre>
       *
       * <code>.opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2;</code>
       */
      public Builder clearExemplar() {  copyOnWrite();
        instance.clearExemplar();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opencensus.proto.metrics.v1.DistributionValue.Bucket)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new io.opencensus.proto.metrics.v1.DistributionValue.Bucket();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "count_",
              "exemplar_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0002\u0002\t" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<io.opencensus.proto.metrics.v1.DistributionValue.Bucket> parser = PARSER;
          if (parser == null) {
            synchronized (io.opencensus.proto.metrics.v1.DistributionValue.Bucket.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<io.opencensus.proto.metrics.v1.DistributionValue.Bucket>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:opencensus.proto.metrics.v1.DistributionValue.Bucket)
    private static final io.opencensus.proto.metrics.v1.DistributionValue.Bucket DEFAULT_INSTANCE;
    static {
      Bucket defaultInstance = new Bucket();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Bucket.class, defaultInstance);
    }

    public static io.opencensus.proto.metrics.v1.DistributionValue.Bucket getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Bucket> PARSER;

    public static com.google.protobuf.Parser<Bucket> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExemplarOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opencensus.proto.metrics.v1.DistributionValue.Exemplar)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Value of the exemplar point. It determines which bucket the exemplar
     * belongs to.
     * </pre>
     *
     * <code>double value = 1;</code>
     * @return The value.
     */
    double getValue();

    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     * @return Whether the timestamp field is set.
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     * @return The timestamp.
     */
    com.google.protobuf.Timestamp getTimestamp();

    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    int getAttachmentsCount();
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    boolean containsAttachments(
        java.lang.String key);
    /**
     * Use {@link #getAttachmentsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getAttachments();
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getAttachmentsMap();
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */

    java.lang.String getAttachmentsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */

    java.lang.String getAttachmentsOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * Exemplars are example points that may be used to annotate aggregated
   * Distribution values. They are metadata that gives information about a
   * particular value added to a Distribution bucket.
   * </pre>
   *
   * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.Exemplar}
   */
  public  static final class Exemplar extends
      com.google.protobuf.GeneratedMessageLite<
          Exemplar, Exemplar.Builder> implements
      // @@protoc_insertion_point(message_implements:opencensus.proto.metrics.v1.DistributionValue.Exemplar)
      ExemplarOrBuilder {
    private Exemplar() {
    }
    public static final int VALUE_FIELD_NUMBER = 1;
    private double value_;
    /**
     * <pre>
     * Value of the exemplar point. It determines which bucket the exemplar
     * belongs to.
     * </pre>
     *
     * <code>double value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public double getValue() {
      return value_;
    }
    /**
     * <pre>
     * Value of the exemplar point. It determines which bucket the exemplar
     * belongs to.
     * </pre>
     *
     * <code>double value = 1;</code>
     * @param value The value to set.
     */
    private void setValue(double value) {
      
      value_ = value;
    }
    /**
     * <pre>
     * Value of the exemplar point. It determines which bucket the exemplar
     * belongs to.
     * </pre>
     *
     * <code>double value = 1;</code>
     */
    private void clearValue() {
      
      value_ = 0D;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 2;
    private com.google.protobuf.Timestamp timestamp_;
    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     */
    @java.lang.Override
    public boolean hasTimestamp() {
      return timestamp_ != null;
    }
    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Timestamp getTimestamp() {
      return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;
    }
    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     */
    private void setTimestamp(com.google.protobuf.Timestamp value) {
      value.getClass();
  timestamp_ = value;
      
      }
    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeTimestamp(com.google.protobuf.Timestamp value) {
      value.getClass();
  if (timestamp_ != null &&
          timestamp_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
        timestamp_ =
          com.google.protobuf.Timestamp.newBuilder(timestamp_).mergeFrom(value).buildPartial();
      } else {
        timestamp_ = value;
      }
      
    }
    /**
     * <pre>
     * The observation (sampling) time of the above value.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp timestamp = 2;</code>
     */
    private void clearTimestamp() {  timestamp_ = null;
      
    }

    public static final int ATTACHMENTS_FIELD_NUMBER = 3;
    private static final class AttachmentsDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.String> attachments_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
    internalGetAttachments() {
      return attachments_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
    internalGetMutableAttachments() {
      if (!attachments_.isMutable()) {
        attachments_ = attachments_.mutableCopy();
      }
      return attachments_;
    }
    @java.lang.Override

    public int getAttachmentsCount() {
      return internalGetAttachments().size();
    }
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    @java.lang.Override

    public boolean containsAttachments(
        java.lang.String key) {
      key.getClass();
      return internalGetAttachments().containsKey(key);
    }
    /**
     * Use {@link #getAttachmentsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getAttachments() {
      return getAttachmentsMap();
    }
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.String> getAttachmentsMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetAttachments());
    }
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    @java.lang.Override

    public java.lang.String getAttachmentsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAttachments();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    @java.lang.Override

    public java.lang.String getAttachmentsOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAttachments();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * Contextual information about the example value.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachments = 3;</code>
     */
    private java.util.Map<java.lang.String, java.lang.String>
    getMutableAttachmentsMap() {
      return internalGetMutableAttachments();
    }

    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(io.opencensus.proto.metrics.v1.DistributionValue.Exemplar prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Exemplars are example points that may be used to annotate aggregated
     * Distribution values. They are metadata that gives information about a
     * particular value added to a Distribution bucket.
     * </pre>
     *
     * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue.Exemplar}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          io.opencensus.proto.metrics.v1.DistributionValue.Exemplar, Builder> implements
        // @@protoc_insertion_point(builder_implements:opencensus.proto.metrics.v1.DistributionValue.Exemplar)
        io.opencensus.proto.metrics.v1.DistributionValue.ExemplarOrBuilder {
      // Construct using io.opencensus.proto.metrics.v1.DistributionValue.Exemplar.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Value of the exemplar point. It determines which bucket the exemplar
       * belongs to.
       * </pre>
       *
       * <code>double value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public double getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * Value of the exemplar point. It determines which bucket the exemplar
       * belongs to.
       * </pre>
       *
       * <code>double value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(double value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * Value of the exemplar point. It determines which bucket the exemplar
       * belongs to.
       * </pre>
       *
       * <code>double value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * The observation (sampling) time of the above value.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp timestamp = 2;</code>
       */
      @java.lang.Override
      public boolean hasTimestamp() {
        return instance.hasTimestamp();
      }
      /**
       * <pre>
       * The observation (sampling) time of the above value.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp timestamp = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.Timestamp getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       * The observation (sampling) time of the above value.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp timestamp = 2;</code>
       */
      public Builder setTimestamp(com.google.protobuf.Timestamp value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
        }
      /**
       * <pre>
       * The observation (sampling) time of the above value.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp timestamp = 2;</code>
       */
      public Builder setTimestamp(
          com.google.protobuf.Timestamp.Builder builderForValue) {
        copyOnWrite();
        instance.setTimestamp(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The observation (sampling) time of the above value.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp timestamp = 2;</code>
       */
      public Builder mergeTimestamp(com.google.protobuf.Timestamp value) {
        copyOnWrite();
        instance.mergeTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * The observation (sampling) time of the above value.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp timestamp = 2;</code>
       */
      public Builder clearTimestamp() {  copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      @java.lang.Override

      public int getAttachmentsCount() {
        return instance.getAttachmentsMap().size();
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */
      @java.lang.Override

      public boolean containsAttachments(
          java.lang.String key) {
        key.getClass();
        return instance.getAttachmentsMap().containsKey(key);
      }

      public Builder clearAttachments() {
        copyOnWrite();
        instance.getMutableAttachmentsMap().clear();
        return this;
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */

      public Builder removeAttachments(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableAttachmentsMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getAttachmentsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getAttachments() {
        return getAttachmentsMap();
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getAttachmentsMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getAttachmentsMap());
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */
      @java.lang.Override

      public java.lang.String getAttachmentsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.String> map =
            instance.getAttachmentsMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */
      @java.lang.Override

      public java.lang.String getAttachmentsOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.String> map =
            instance.getAttachmentsMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */
      public Builder putAttachments(
          java.lang.String key,
          java.lang.String value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableAttachmentsMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Contextual information about the example value.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachments = 3;</code>
       */
      public Builder putAllAttachments(
          java.util.Map<java.lang.String, java.lang.String> values) {
        copyOnWrite();
        instance.getMutableAttachmentsMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opencensus.proto.metrics.v1.DistributionValue.Exemplar)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new io.opencensus.proto.metrics.v1.DistributionValue.Exemplar();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "value_",
              "timestamp_",
              "attachments_",
              AttachmentsDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0001\u0000\u0000\u0001\u0000\u0002\t" +
                "\u00032";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<io.opencensus.proto.metrics.v1.DistributionValue.Exemplar> parser = PARSER;
          if (parser == null) {
            synchronized (io.opencensus.proto.metrics.v1.DistributionValue.Exemplar.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<io.opencensus.proto.metrics.v1.DistributionValue.Exemplar>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:opencensus.proto.metrics.v1.DistributionValue.Exemplar)
    private static final io.opencensus.proto.metrics.v1.DistributionValue.Exemplar DEFAULT_INSTANCE;
    static {
      Exemplar defaultInstance = new Exemplar();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Exemplar.class, defaultInstance);
    }

    public static io.opencensus.proto.metrics.v1.DistributionValue.Exemplar getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Exemplar> PARSER;

    public static com.google.protobuf.Parser<Exemplar> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public static final int COUNT_FIELD_NUMBER = 1;
  private long count_;
  /**
   * <pre>
   * The number of values in the population. Must be non-negative. This value
   * must equal the sum of the values in bucket_counts if a histogram is
   * provided.
   * </pre>
   *
   * <code>int64 count = 1;</code>
   * @return The count.
   */
  @java.lang.Override
  public long getCount() {
    return count_;
  }
  /**
   * <pre>
   * The number of values in the population. Must be non-negative. This value
   * must equal the sum of the values in bucket_counts if a histogram is
   * provided.
   * </pre>
   *
   * <code>int64 count = 1;</code>
   * @param value The count to set.
   */
  private void setCount(long value) {
    
    count_ = value;
  }
  /**
   * <pre>
   * The number of values in the population. Must be non-negative. This value
   * must equal the sum of the values in bucket_counts if a histogram is
   * provided.
   * </pre>
   *
   * <code>int64 count = 1;</code>
   */
  private void clearCount() {
    
    count_ = 0L;
  }

  public static final int SUM_FIELD_NUMBER = 2;
  private double sum_;
  /**
   * <pre>
   * The sum of the values in the population. If count is zero then this field
   * must be zero.
   * </pre>
   *
   * <code>double sum = 2;</code>
   * @return The sum.
   */
  @java.lang.Override
  public double getSum() {
    return sum_;
  }
  /**
   * <pre>
   * The sum of the values in the population. If count is zero then this field
   * must be zero.
   * </pre>
   *
   * <code>double sum = 2;</code>
   * @param value The sum to set.
   */
  private void setSum(double value) {
    
    sum_ = value;
  }
  /**
   * <pre>
   * The sum of the values in the population. If count is zero then this field
   * must be zero.
   * </pre>
   *
   * <code>double sum = 2;</code>
   */
  private void clearSum() {
    
    sum_ = 0D;
  }

  public static final int SUM_OF_SQUARED_DEVIATION_FIELD_NUMBER = 3;
  private double sumOfSquaredDeviation_;
  /**
   * <pre>
   * The sum of squared deviations from the mean of the values in the
   * population. For values x_i this is:
   *     Sum[i=1..n]((x_i - mean)^2)
   * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
   * describes Welford's method for accumulating this sum in one pass.
   * If count is zero then this field must be zero.
   * </pre>
   *
   * <code>double sum_of_squared_deviation = 3;</code>
   * @return The sumOfSquaredDeviation.
   */
  @java.lang.Override
  public double getSumOfSquaredDeviation() {
    return sumOfSquaredDeviation_;
  }
  /**
   * <pre>
   * The sum of squared deviations from the mean of the values in the
   * population. For values x_i this is:
   *     Sum[i=1..n]((x_i - mean)^2)
   * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
   * describes Welford's method for accumulating this sum in one pass.
   * If count is zero then this field must be zero.
   * </pre>
   *
   * <code>double sum_of_squared_deviation = 3;</code>
   * @param value The sumOfSquaredDeviation to set.
   */
  private void setSumOfSquaredDeviation(double value) {
    
    sumOfSquaredDeviation_ = value;
  }
  /**
   * <pre>
   * The sum of squared deviations from the mean of the values in the
   * population. For values x_i this is:
   *     Sum[i=1..n]((x_i - mean)^2)
   * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
   * describes Welford's method for accumulating this sum in one pass.
   * If count is zero then this field must be zero.
   * </pre>
   *
   * <code>double sum_of_squared_deviation = 3;</code>
   */
  private void clearSumOfSquaredDeviation() {
    
    sumOfSquaredDeviation_ = 0D;
  }

  public static final int BUCKET_OPTIONS_FIELD_NUMBER = 4;
  private io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucketOptions_;
  /**
   * <pre>
   * Don't change bucket boundaries within a TimeSeries if your backend doesn't
   * support this.
   * TODO(issue #152): consider not required to send bucket options for
   * optimization.
   * </pre>
   *
   * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
   */
  @java.lang.Override
  public boolean hasBucketOptions() {
    return bucketOptions_ != null;
  }
  /**
   * <pre>
   * Don't change bucket boundaries within a TimeSeries if your backend doesn't
   * support this.
   * TODO(issue #152): consider not required to send bucket options for
   * optimization.
   * </pre>
   *
   * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
   */
  @java.lang.Override
  public io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions getBucketOptions() {
    return bucketOptions_ == null ? io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.getDefaultInstance() : bucketOptions_;
  }
  /**
   * <pre>
   * Don't change bucket boundaries within a TimeSeries if your backend doesn't
   * support this.
   * TODO(issue #152): consider not required to send bucket options for
   * optimization.
   * </pre>
   *
   * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
   */
  private void setBucketOptions(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions value) {
    value.getClass();
  bucketOptions_ = value;
    
    }
  /**
   * <pre>
   * Don't change bucket boundaries within a TimeSeries if your backend doesn't
   * support this.
   * TODO(issue #152): consider not required to send bucket options for
   * optimization.
   * </pre>
   *
   * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeBucketOptions(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions value) {
    value.getClass();
  if (bucketOptions_ != null &&
        bucketOptions_ != io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.getDefaultInstance()) {
      bucketOptions_ =
        io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.newBuilder(bucketOptions_).mergeFrom(value).buildPartial();
    } else {
      bucketOptions_ = value;
    }
    
  }
  /**
   * <pre>
   * Don't change bucket boundaries within a TimeSeries if your backend doesn't
   * support this.
   * TODO(issue #152): consider not required to send bucket options for
   * optimization.
   * </pre>
   *
   * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
   */
  private void clearBucketOptions() {  bucketOptions_ = null;
    
  }

  public static final int BUCKETS_FIELD_NUMBER = 5;
  private com.google.protobuf.Internal.ProtobufList<io.opencensus.proto.metrics.v1.DistributionValue.Bucket> buckets_;
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  @java.lang.Override
  public java.util.List<io.opencensus.proto.metrics.v1.DistributionValue.Bucket> getBucketsList() {
    return buckets_;
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  public java.util.List<? extends io.opencensus.proto.metrics.v1.DistributionValue.BucketOrBuilder> 
      getBucketsOrBuilderList() {
    return buckets_;
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  @java.lang.Override
  public int getBucketsCount() {
    return buckets_.size();
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  @java.lang.Override
  public io.opencensus.proto.metrics.v1.DistributionValue.Bucket getBuckets(int index) {
    return buckets_.get(index);
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  public io.opencensus.proto.metrics.v1.DistributionValue.BucketOrBuilder getBucketsOrBuilder(
      int index) {
    return buckets_.get(index);
  }
  private void ensureBucketsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<io.opencensus.proto.metrics.v1.DistributionValue.Bucket> tmp = buckets_;
    if (!tmp.isModifiable()) {
      buckets_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  private void setBuckets(
      int index, io.opencensus.proto.metrics.v1.DistributionValue.Bucket value) {
    value.getClass();
  ensureBucketsIsMutable();
    buckets_.set(index, value);
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  private void addBuckets(io.opencensus.proto.metrics.v1.DistributionValue.Bucket value) {
    value.getClass();
  ensureBucketsIsMutable();
    buckets_.add(value);
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  private void addBuckets(
      int index, io.opencensus.proto.metrics.v1.DistributionValue.Bucket value) {
    value.getClass();
  ensureBucketsIsMutable();
    buckets_.add(index, value);
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  private void addAllBuckets(
      java.lang.Iterable<? extends io.opencensus.proto.metrics.v1.DistributionValue.Bucket> values) {
    ensureBucketsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, buckets_);
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  private void clearBuckets() {
    buckets_ = emptyProtobufList();
  }
  /**
   * <pre>
   * If the distribution does not have a histogram, then omit this field.
   * If there is a histogram, then the sum of the values in the Bucket counts
   * must equal the value in the count field of the distribution.
   * </pre>
   *
   * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
   */
  private void removeBuckets(int index) {
    ensureBucketsIsMutable();
    buckets_.remove(index);
  }

  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static io.opencensus.proto.metrics.v1.DistributionValue parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(io.opencensus.proto.metrics.v1.DistributionValue prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * Distribution contains summary statistics for a population of values. It
   * optionally contains a histogram representing the distribution of those
   * values across a set of buckets.
   * </pre>
   *
   * Protobuf type {@code opencensus.proto.metrics.v1.DistributionValue}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        io.opencensus.proto.metrics.v1.DistributionValue, Builder> implements
      // @@protoc_insertion_point(builder_implements:opencensus.proto.metrics.v1.DistributionValue)
      io.opencensus.proto.metrics.v1.DistributionValueOrBuilder {
    // Construct using io.opencensus.proto.metrics.v1.DistributionValue.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The number of values in the population. Must be non-negative. This value
     * must equal the sum of the values in bucket_counts if a histogram is
     * provided.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     * @return The count.
     */
    @java.lang.Override
    public long getCount() {
      return instance.getCount();
    }
    /**
     * <pre>
     * The number of values in the population. Must be non-negative. This value
     * must equal the sum of the values in bucket_counts if a histogram is
     * provided.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     * @param value The count to set.
     * @return This builder for chaining.
     */
    public Builder setCount(long value) {
      copyOnWrite();
      instance.setCount(value);
      return this;
    }
    /**
     * <pre>
     * The number of values in the population. Must be non-negative. This value
     * must equal the sum of the values in bucket_counts if a histogram is
     * provided.
     * </pre>
     *
     * <code>int64 count = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearCount() {
      copyOnWrite();
      instance.clearCount();
      return this;
    }

    /**
     * <pre>
     * The sum of the values in the population. If count is zero then this field
     * must be zero.
     * </pre>
     *
     * <code>double sum = 2;</code>
     * @return The sum.
     */
    @java.lang.Override
    public double getSum() {
      return instance.getSum();
    }
    /**
     * <pre>
     * The sum of the values in the population. If count is zero then this field
     * must be zero.
     * </pre>
     *
     * <code>double sum = 2;</code>
     * @param value The sum to set.
     * @return This builder for chaining.
     */
    public Builder setSum(double value) {
      copyOnWrite();
      instance.setSum(value);
      return this;
    }
    /**
     * <pre>
     * The sum of the values in the population. If count is zero then this field
     * must be zero.
     * </pre>
     *
     * <code>double sum = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearSum() {
      copyOnWrite();
      instance.clearSum();
      return this;
    }

    /**
     * <pre>
     * The sum of squared deviations from the mean of the values in the
     * population. For values x_i this is:
     *     Sum[i=1..n]((x_i - mean)^2)
     * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
     * describes Welford's method for accumulating this sum in one pass.
     * If count is zero then this field must be zero.
     * </pre>
     *
     * <code>double sum_of_squared_deviation = 3;</code>
     * @return The sumOfSquaredDeviation.
     */
    @java.lang.Override
    public double getSumOfSquaredDeviation() {
      return instance.getSumOfSquaredDeviation();
    }
    /**
     * <pre>
     * The sum of squared deviations from the mean of the values in the
     * population. For values x_i this is:
     *     Sum[i=1..n]((x_i - mean)^2)
     * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
     * describes Welford's method for accumulating this sum in one pass.
     * If count is zero then this field must be zero.
     * </pre>
     *
     * <code>double sum_of_squared_deviation = 3;</code>
     * @param value The sumOfSquaredDeviation to set.
     * @return This builder for chaining.
     */
    public Builder setSumOfSquaredDeviation(double value) {
      copyOnWrite();
      instance.setSumOfSquaredDeviation(value);
      return this;
    }
    /**
     * <pre>
     * The sum of squared deviations from the mean of the values in the
     * population. For values x_i this is:
     *     Sum[i=1..n]((x_i - mean)^2)
     * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
     * describes Welford's method for accumulating this sum in one pass.
     * If count is zero then this field must be zero.
     * </pre>
     *
     * <code>double sum_of_squared_deviation = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearSumOfSquaredDeviation() {
      copyOnWrite();
      instance.clearSumOfSquaredDeviation();
      return this;
    }

    /**
     * <pre>
     * Don't change bucket boundaries within a TimeSeries if your backend doesn't
     * support this.
     * TODO(issue #152): consider not required to send bucket options for
     * optimization.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
     */
    @java.lang.Override
    public boolean hasBucketOptions() {
      return instance.hasBucketOptions();
    }
    /**
     * <pre>
     * Don't change bucket boundaries within a TimeSeries if your backend doesn't
     * support this.
     * TODO(issue #152): consider not required to send bucket options for
     * optimization.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
     */
    @java.lang.Override
    public io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions getBucketOptions() {
      return instance.getBucketOptions();
    }
    /**
     * <pre>
     * Don't change bucket boundaries within a TimeSeries if your backend doesn't
     * support this.
     * TODO(issue #152): consider not required to send bucket options for
     * optimization.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
     */
    public Builder setBucketOptions(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions value) {
      copyOnWrite();
      instance.setBucketOptions(value);
      return this;
      }
    /**
     * <pre>
     * Don't change bucket boundaries within a TimeSeries if your backend doesn't
     * support this.
     * TODO(issue #152): consider not required to send bucket options for
     * optimization.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
     */
    public Builder setBucketOptions(
        io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Builder builderForValue) {
      copyOnWrite();
      instance.setBucketOptions(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Don't change bucket boundaries within a TimeSeries if your backend doesn't
     * support this.
     * TODO(issue #152): consider not required to send bucket options for
     * optimization.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
     */
    public Builder mergeBucketOptions(io.opencensus.proto.metrics.v1.DistributionValue.BucketOptions value) {
      copyOnWrite();
      instance.mergeBucketOptions(value);
      return this;
    }
    /**
     * <pre>
     * Don't change bucket boundaries within a TimeSeries if your backend doesn't
     * support this.
     * TODO(issue #152): consider not required to send bucket options for
     * optimization.
     * </pre>
     *
     * <code>.opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4;</code>
     */
    public Builder clearBucketOptions() {  copyOnWrite();
      instance.clearBucketOptions();
      return this;
    }

    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    @java.lang.Override
    public java.util.List<io.opencensus.proto.metrics.v1.DistributionValue.Bucket> getBucketsList() {
      return java.util.Collections.unmodifiableList(
          instance.getBucketsList());
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    @java.lang.Override
    public int getBucketsCount() {
      return instance.getBucketsCount();
    }/**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    @java.lang.Override
    public io.opencensus.proto.metrics.v1.DistributionValue.Bucket getBuckets(int index) {
      return instance.getBuckets(index);
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder setBuckets(
        int index, io.opencensus.proto.metrics.v1.DistributionValue.Bucket value) {
      copyOnWrite();
      instance.setBuckets(index, value);
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder setBuckets(
        int index, io.opencensus.proto.metrics.v1.DistributionValue.Bucket.Builder builderForValue) {
      copyOnWrite();
      instance.setBuckets(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder addBuckets(io.opencensus.proto.metrics.v1.DistributionValue.Bucket value) {
      copyOnWrite();
      instance.addBuckets(value);
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder addBuckets(
        int index, io.opencensus.proto.metrics.v1.DistributionValue.Bucket value) {
      copyOnWrite();
      instance.addBuckets(index, value);
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder addBuckets(
        io.opencensus.proto.metrics.v1.DistributionValue.Bucket.Builder builderForValue) {
      copyOnWrite();
      instance.addBuckets(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder addBuckets(
        int index, io.opencensus.proto.metrics.v1.DistributionValue.Bucket.Builder builderForValue) {
      copyOnWrite();
      instance.addBuckets(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder addAllBuckets(
        java.lang.Iterable<? extends io.opencensus.proto.metrics.v1.DistributionValue.Bucket> values) {
      copyOnWrite();
      instance.addAllBuckets(values);
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder clearBuckets() {
      copyOnWrite();
      instance.clearBuckets();
      return this;
    }
    /**
     * <pre>
     * If the distribution does not have a histogram, then omit this field.
     * If there is a histogram, then the sum of the values in the Bucket counts
     * must equal the value in the count field of the distribution.
     * </pre>
     *
     * <code>repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5;</code>
     */
    public Builder removeBuckets(int index) {
      copyOnWrite();
      instance.removeBuckets(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:opencensus.proto.metrics.v1.DistributionValue)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new io.opencensus.proto.metrics.v1.DistributionValue();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "count_",
            "sum_",
            "sumOfSquaredDeviation_",
            "bucketOptions_",
            "buckets_",
            io.opencensus.proto.metrics.v1.DistributionValue.Bucket.class,
          };
          java.lang.String info =
              "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0001\u0000\u0001\u0002\u0002\u0000" +
              "\u0003\u0000\u0004\t\u0005\u001b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<io.opencensus.proto.metrics.v1.DistributionValue> parser = PARSER;
        if (parser == null) {
          synchronized (io.opencensus.proto.metrics.v1.DistributionValue.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<io.opencensus.proto.metrics.v1.DistributionValue>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:opencensus.proto.metrics.v1.DistributionValue)
  private static final io.opencensus.proto.metrics.v1.DistributionValue DEFAULT_INSTANCE;
  static {
    DistributionValue defaultInstance = new DistributionValue();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      DistributionValue.class, defaultInstance);
  }

  public static io.opencensus.proto.metrics.v1.DistributionValue getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<DistributionValue> PARSER;

  public static com.google.protobuf.Parser<DistributionValue> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

